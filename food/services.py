"""
STATUSES: not started, cooking, cooked, finished

BUENO HTTP POST /
```
    order: [
        {
            dish: string
            quantity: number
        }, ...      
    ]
```
RESPONSE:
```
    {
        id: string,  // generated by restaurant
        status: string
    }
```


WEBHOOK HTTP POST <SELECT>
```
    {
        id: string,
        status: string
    }
```

=================================================================

STATUS: not started, cooking, cooked, finished

MELANGE HTTP POST /api/orders
```
    order: [
        {
            dish: string
            quantity: number
        }, ...      
    ]
```
```
    {
        id: string,
        status: string
    }
```

MELANGE HTTP GET /api/orders/<ID>
```
    {
        status: string
    }
```
"""

from collections import defaultdict
from datetime import datetime, date, time
import json
from time import sleep
import uuid

import httpx
from shared.cache import CacheService
from .models import DishOrderItem, Order
from .enums import Restaurant
from config import celery_app


class OrderInCache:
    """
    {
        "bueno"|"melange": {
            "external_id": string,
            "status": string,
            "dishes": [
                {
                    "dish": string,
                    "quantity": number,
                }, ...
            ]
        }
    }
    """

    def __init__(self) -> None:
        # self.orders: dict[str, dict[str, list[dict]]] = defaultdict(lambda: defaultdict(list))
        self.orders: dict[str, dict[str, str | list[dict]]] = defaultdict(dict)

    def append(self, restaurant: str, item: DishOrderItem):
        if not self.orders[restaurant]:
            self.orders[restaurant] = {
                "external_id": "",
                "status": "not_started",
                "dishes": [
                    {
                        "dish": item.dish.name,
                        "quantity": item.quantity,
                    }
                ],
            }
        else:
            self.orders[restaurant]["dishes"].append(
                {
                    "dish": item.dish.name,
                    "quantity": item.quantity,
                }
            )


# todo: uncomment
# @celery_app.task
def melange_order_processing(order: OrderInCache):
    while (current_status := order.orders[Restaurant.MELANGE]["status"]) != "finished":
        if current_status == "not_started":
            if not order.orders[Restaurant.MELANGE]["external_id"]:
                payload = {"order": order.orders[Restaurant.MELANGE]["dishes"]}
                response = httpx.post("http://localhost:8001/api/orders", json=payload)
                response.raise_for_status()
                order.orders[Restaurant.MELANGE]["external_id"] = response.json()["id"]
            else:
                external_order_id = order.orders[Restaurant.MELANGE]["external_id"]
                response = httpx.get(
                    f"http://localhost:8001/api/orders/{external_order_id}"
                )
                response.raise_for_status()

                # update the status of order
                order.orders[Restaurant.MELANGE]["status"] = response.json()["status"]

                print(f"Current status is {current_status}. Waiting 1 second")
                sleep(1)
        elif current_status == "cooking":
            external_order_id = order.orders[Restaurant.MELANGE]["external_id"]
            response = httpx.get(
                f"http://localhost:8001/api/orders/{external_order_id}"
            )
            response.raise_for_status()

            # update the status of order
            order.orders[Restaurant.MELANGE]["status"] = response.json()["status"]

            print(f"Current status is {current_status}. Waiting 3 second")
            sleep(3)
        elif current_status == "cooked":
            print(f"ðŸšš CALLING DELIVERY SERVICE TO PASS THE FOOD ORDER")
        else:
            raise ValueError(f"Status {current_status} is not supported")


def bueno_order_processing(order: OrderInCache):
    print("BUENO===============================")
    print(order.orders)
    print("BUENO===============================")


# todo: uncomment
# @celery_app.task
def _schedule_order(order: Order):
    """Start processing restaurants orders.

    workflow:
    1. create temporary orders
    2. call restaurants APIs
    3. process orders in background
    """

    # melange_order: list[DishOrderItem] = []
    # bueno_order: list[DishOrderItem] = []

    order_in_cache = OrderInCache()

    for item in order.items.all():
        if (restaurant := item.dish.restaurant.name.lower()) == Restaurant.MELANGE:
            order_in_cache.append(restaurant, item)
        elif item.dish.restaurant.name.lower() == Restaurant.BUENO:
            order_in_cache.append(restaurant, item)
        else:
            raise ValueError(
                f"Can not create order for {item.dish.restaurant.name} restaurant"
            )

    order_key = str(uuid.uuid4())
    cache = CacheService()

    cache.set(
        namespace="restaurants_order", key=order_key, instance=order_in_cache.orders
    )

    melange_order_processing(order_in_cache)
    bueno_order_processing(order_in_cache)


def schedule_order(order: Order):
    """Add the task to the queue for the future processing."""

    assert type(order.eta) is date

    # todo: remove
    _schedule_order(order)
    return None

    # 2025-03-06  -> 2025-03-06-00:00:00 UTC
    if order.eta == date.today():
        print(f"The order will be started processing now")
        return schedule_order_task.delay(order)
    else:
        # ETA: 3:00AM will be sent to restaurant APIs
        eta = datetime.combine(order.eta, time(hour=3))
        print(f"The order will be started processing {eta}")
        return schedule_order_task.apply_async(args=(order,), eta=eta)
