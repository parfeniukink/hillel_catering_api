"""
STATUSES: not started, cooking, cooked, finished

BUENO HTTP POST /
```
    order: [
        {
            dish: string
            quantity: number
        }, ...
    ]
```
RESPONSE:
```
    {
        id: string,  // generated by restaurant
        status: string
    }
```


WEBHOOK HTTP POST <SELECT>
```
    {
        id: string,
        status: string
    }
```

=================================================================

STATUS: not started, cooking, cooked, finished

MELANGE HTTP POST /api/orders
```
    order: [
        {
            dish: string
            quantity: number
        }, ...
    ]
```
```
    {
        id: string,
        status: string
    }
```

MELANGE HTTP GET /api/orders/<ID>
```
    {
        status: string
    }
```
"""

import uuid
from collections import defaultdict
from collections.abc import Iterable
from datetime import date, datetime, time
from time import sleep

from config import celery_app
from shared.cache import CacheService

from .enums import OrderStatus, Restaurant
from .models import DishOrderItem, Order
from .models import Restaurant as RestaurantModel
from .providers import bueno, melange, uklon


class OrderInCache:
    """
    {
        "bueno"|"melange": {
            "external_id": string,
            "status": string,
            "dishes": [
                {
                    "dish": string,
                    "quantity": number,
                }, ...
            ]
        }
    }
    """

    def __init__(self, internal_order_id: int) -> None:
        # self.orders: dict[str, dict[str, list[dict]]] = defaultdict(lambda: defaultdict(list))
        self.internal_order_id: int = internal_order_id
        self.orders: dict = defaultdict(lambda: defaultdict(dict))

        # possibly could include the address?

    def append(self, restaurant: str, item: DishOrderItem):
        if not self.orders[restaurant]:
            self.orders[restaurant] = {
                "external_id": "",
                "status": "not_started",
                "dishes": [
                    {
                        "dish": item.dish.name,
                        "quantity": item.quantity,
                    }
                ],
            }
        else:
            self.orders[restaurant]["dishes"].append(
                {
                    "dish": item.dish.name,
                    "quantity": item.quantity,
                }
            )


def validate_all_external_orders_cooked(order: OrderInCache) -> bool:
    flag = True

    for rest, _order in order.orders.items():
        if rest == Restaurant.MELANGE:
            if _order["status"] not in (
                melange.OrderStatus.COOKED,
                melange.OrderStatus.FINISHED,
            ):
                flag = False
                break
        elif rest == Restaurant.BUENO:
            if _order["status"] != melange.OrderStatus.COOKED:
                flag = False
                break

    # note: this is not a part of a validation function!
    # todo: remove, since moved to concrete provider implementation
    # todo: implement in melange_order_processing and bueno_order_processing
    # if flag is True:
    #     Order.update_from_restaurant_status(
    #         id_=order.internal_order_id, status="finished"
    #     )

    return flag


# @celery_app.task
def melange_order_processing(cached_order: OrderInCache):
    provider = melange.Provider()

    while (
        current_status := cached_order.orders[Restaurant.MELANGE]["status"]
    ) != melange.OrderStatus.FINISHED:
        print(f"====>>>> {current_status}, {id(cached_order.orders)}")

        if current_status == OrderStatus.NOT_STARTED:
            if not cached_order.orders[Restaurant.MELANGE]["external_id"]:
                response: melange.OrderResponse = provider.create_order(
                    melange.OrderRequestBody(
                        order=[
                            melange.OrderItem(**item)
                            for item in cached_order.orders[Restaurant.MELANGE][
                                "dishes"
                            ]
                        ]
                    )
                )
                # update cache representation
                cached_order.orders[Restaurant.MELANGE]["external_id"] = response.id
                # skip database update, since "not started" is default value
            else:
                external_order_id = cached_order.orders[Restaurant.MELANGE][
                    "external_id"
                ]
                response = provider.get_order(order_id=external_order_id)
                print(f"CHECKING MELANGE ORDER: {external_order_id}")

                if current_status != response.status:  # status changed
                    cached_order.orders[Restaurant.MELANGE][
                        "status"
                    ] = response.status  # wait for cooking

                    Order.update_from_restaurant_status(
                        id_=cached_order.internal_order_id,
                        restaurant=Restaurant.MELANGE,
                        status=response.status,
                    )

                sleep(1)
        elif current_status == "cooking":
            external_order_id = cached_order.orders[Restaurant.MELANGE]["external_id"]
            response = provider.get_order(order_id=external_order_id)

            if current_status != response.status:  # if status changed
                cached_order.orders[Restaurant.MELANGE]["status"] = response.status
                Order.update_from_restaurant_status(
                    id_=cached_order.internal_order_id,
                    restaurant=Restaurant.MELANGE,
                    status=response.status,
                )

            print(f"Current status is {current_status}. Waiting 3 second")
            sleep(3)
        elif current_status == "cooked":
            if validate_all_external_orders_cooked(cached_order):
                # note: instead of doing this through the provider mapping
                Order.objects.update(
                    id_=cached_order.internal_order_id, status=OrderStatus.COOKED
                )

            break


@celery_app.task
def bueno_order_processing(cached_order: OrderInCache):
    provider = bueno.Provider()

    response: bueno.OrderResponse = provider.create_order(
        bueno.OrderRequestBody(
            order=[
                bueno.OrderItem(**item)
                for item in cached_order.orders[Restaurant.BUENO]["dishes"]
            ]
        )
    )
    # update cache representation
    cached_order.orders[Restaurant.BUENO]["external_id"] = response.id

    print("BUENO ORDER PROCESSED")


# @celery_app.task
def delivery_order(order: OrderInCache, restaurants: Iterable[RestaurantModel]):
    """Using random provider - start processing delivery orders."""

    print(f"ðŸšš DELIVERY PROCESSING STARTED")
    from pprint import pprint

    # checking orders in background
    # note: always reaches ``break`` when we comment Celery
    while True:
        if validate_all_external_orders_cooked(order):
            break
        else:
            sleep(3)
            print(f"WAITING FOR ORDERS TO BE COOKED")

    # todo: start from here

    print(f"ðŸšš DELIVERED all the orders...")


def _delivery_order_task(order: OrderInCache, restaurants: Iterable[RestaurantModel]):
    """Using random provider - start processing delivery orders."""

    provider = uklon.Provider()
    addresses: list[str] = []
    comments: list[str] = []

    for rest in restaurants:
        addresses.append(rest.address)
        external_id: str = order.orders[rest.name.lower()]["external_id"]
        comments.append(f"ORDER: {external_id}")

    _response: uklon.OrderResponse = provider.create_order(
        uklon.OrderRequestBody(addresses=addresses, comments=comments)
    )

    current_status: uklon.OrderStatus = uklon.OrderStatus.NOT_STARTED

    while current_status != uklon.OrderStatus.DELIVERED:
        response: uklon.OrderResponse = provider.get_order(_response.id)

        if current_status == response.status:
            sleep(1)
            continue

        # SOLID: ...
        current_status = response.status  # DELIVERY, DELIVERED

        # update storage
        Order.update_from_restaurant_status(
            id_=order.internal_order_id, status=current_status, delivery=True
        )


# @celery_app.task
def _schedule_order(order: Order):
    """Start processing restaurants orders.

    WORKFLOW:
    1. create temporary orders
    2. call restaurants APIs
    3. process orders in background


    NOTES
    - [order: Order] includes all restaurantes
    - each provider task will run ``validate_external_orders_ready(order)``
        and the last one will update the status to ``DRIVER_LOOKUP``
    """

    order_in_cache = OrderInCache(internal_order_id=order.pk)
    delivery_restaurants: set[RestaurantModel] = set()

    for item in order.items.all():
        if (restaurant := item.dish.restaurant.name.lower()) == Restaurant.MELANGE:
            delivery_restaurants.add(item.dish.restaurant)
            order_in_cache.append(restaurant, item)
        elif item.dish.restaurant.name.lower() == Restaurant.BUENO:
            delivery_restaurants.add(item.dish.restaurant)
            order_in_cache.append(restaurant, item)
        else:
            raise ValueError(
                f"Can not create order for {item.dish.restaurant.name} restaurant"
            )

    order_key = str(uuid.uuid4())
    cache = CacheService()

    cache.set(
        namespace="restaurants_order", key=order_key, instance=order_in_cache.orders
    )

    melange_order_processing(order_in_cache)
    # melange_order_processing.delay(order_in_cache)
    # bueno_order_processing.delay(order_in_cache)  # won't change the value due to the webhook
    delivery_order(order_in_cache, delivery_restaurants)


def schedule_order(order: Order):
    """Add the task to the queue for the future processing."""

    assert type(order.eta) is date

    # todo: remove
    # _schedule_order(order)
    # return None

    # 2025-03-06  -> 2025-03-06-00:00:00 UTC
    if order.eta == date.today():
        print(f"The order will be started processing now")
        # return _schedule_order.apply_async(args=(order,))
        return _schedule_order(order)
    else:
        # ETA: 3:00AM will be sent to restaurant APIs
        eta = datetime.combine(order.eta, time(hour=3))
        print(f"The order will be started processing {eta}")
        # return _schedule_order.apply_async(args=(order,), eta=eta)
