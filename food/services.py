"""
STATUSES: not started, cooking, cooked, finished

BUENO HTTP POST /
```
    order: [
        {
            dish: string
            quantity: number
        }, ...
    ]
```
RESPONSE:
```
    {
        id: string,  // generated by restaurant
        status: string
    }
```


WEBHOOK HTTP POST <SELECT>
```
    {
        id: string,
        status: string
    }
```

=================================================================

STATUS: not started, cooking, cooked, finished

MELANGE HTTP POST /api/orders
```
    order: [
        {
            dish: string
            quantity: number
        }, ...
    ]
```
```
    {
        id: string,
        status: string
    }
```

MELANGE HTTP GET /api/orders/<ID>
```
    {
        status: string
    }
```
"""

import uuid
from collections import defaultdict
from datetime import date, datetime, time
from time import sleep

from config import celery_app
from shared.cache import CacheService

from .constants import RESTAURANT_TO_INTERNAL_STATUSES
from .enums import OrderStatus, Restaurant
from .models import DishOrderItem, Order
from .providers import bueno, melange


class OrderInCache:
    """
    {
        "bueno"|"melange": {
            "external_id": string,
            "status": string,
            "dishes": [
                {
                    "dish": string,
                    "quantity": number,
                }, ...
            ]
        }
    }
    """

    def __init__(self, internal_order_id: int) -> None:
        # self.orders: dict[str, dict[str, list[dict]]] = defaultdict(lambda: defaultdict(list))
        self.internal_order_id: int = internal_order_id
        self.orders: dict = defaultdict(dict)

    def append(self, restaurant: str, item: DishOrderItem):
        if not self.orders[restaurant]:
            self.orders[restaurant] = {
                "external_id": "",
                "status": "not_started",
                "dishes": [
                    {
                        "dish": item.dish.name,
                        "quantity": item.quantity,
                    }
                ],
            }
        else:
            self.orders[restaurant]["dishes"].append(
                {
                    "dish": item.dish.name,
                    "quantity": item.quantity,
                }
            )


def validate_external_orders_ready(order: OrderInCache) -> bool:
    flag = True

    for rest, _order in order.orders.items():
        if rest == Restaurant.MELANGE:
            if _order["status"] != melange.OrderStatus.COOKED:
                flag = False
                break
        elif rest == Restaurant.BUENO:
            if _order["status"] != melange.OrderStatus.COOKED:
                flag = False
                break

    if flag is True:
        Order.update_from_provider_status(
            id_=order.internal_order_id, status="finished"
        )

    return flag


@celery_app.task
def melange_order_processing(cached_order: OrderInCache):
    """
    0: not started
    3: cooking
    8: cooked
    10: finished

    1: not started -> db.not started
    2: not started -> db.not started
    4: cooking -> db.cooking
    7: cooking -> db.cooking

    9: cooked -> db.cooking
    --
    12: cooked -> db.cooking

    """

    provider = melange.Provider()

    while (
        current_status := cached_order.orders[Restaurant.MELANGE]["status"]
    ) != melange.OrderStatus.FINISHED:
        print(f"====>>>> {current_status}, {id(cached_order.orders)}")

        if current_status == OrderStatus.NOT_STARTED:
            if not cached_order.orders[Restaurant.MELANGE]["external_id"]:
                response: melange.OrderResponse = provider.create_order(
                    melange.OrderRequestBody(
                        order=[
                            melange.OrderItem(**item)
                            for item in cached_order.orders[Restaurant.MELANGE][
                                "dishes"
                            ]
                        ]
                    )
                )
                # update cache representation
                cached_order.orders[Restaurant.MELANGE]["external_id"] = response.id
                # skip database update, since "not started" is default value
            else:
                external_order_id = cached_order.orders[Restaurant.MELANGE][
                    "external_id"
                ]
                response = provider.get_order(order_id=external_order_id)

                if current_status != response.status:  # status changed
                    cached_order.orders[Restaurant.MELANGE][
                        "status"
                    ] = response.status  # wait for cooking

                    Order.update_from_provider_status(
                        id_=cached_order.internal_order_id, status=response.status
                    )

                print(f"Current status is {current_status}. Waiting 1 second")
                sleep(1)
        elif current_status == "cooking":
            external_order_id = cached_order.orders[Restaurant.MELANGE]["external_id"]
            response = provider.get_order(order_id=external_order_id)

            if current_status != response.status:  # if status changed
                cached_order.orders[Restaurant.MELANGE]["status"] = response.status
                Order.update_from_provider_status(
                    id_=cached_order.internal_order_id, status=response.status
                )

            print(f"Current status is {current_status}. Waiting 3 second")
            sleep(3)
        elif current_status == "cooked":
            # optional, since will be removed
            # order.orders[Restaurant.MELANGE]["status"] = "cooked"
            validate_external_orders_ready(cached_order)
            break


@celery_app.task
def bueno_order_processing(order: OrderInCache):
    print("BUENO ORDER PROCESSING")
    print("=" * 30)

    print(f"====>>>>  {id(order.orders)}")
    order.orders[Restaurant.BUENO]["status"] = bueno.OrderStatus.COOKED
    validate_external_orders_ready(order)

    print("=" * 30)
    print("BUENO ORDER PROCESSED")


@celery_app.task
def _schedule_order(order: Order):
    """Start processing restaurants orders.

    WORKFLOW:
    1. create temporary orders
    2. call restaurants APIs
    3. process orders in background


    NOTES
    - [order: Order] includes all restaurantes
    - each provider task will run ``validate_external_orders_ready(order)``
        and the last one will update the status to ``DRIVER_LOOKUP``
    """

    order_in_cache = OrderInCache(internal_order_id=order.pk)

    for item in order.items.all():
        if (restaurant := item.dish.restaurant.name.lower()) == Restaurant.MELANGE:
            order_in_cache.append(restaurant, item)
        elif item.dish.restaurant.name.lower() == Restaurant.BUENO:
            order_in_cache.append(restaurant, item)
        else:
            raise ValueError(
                f"Can not create order for {item.dish.restaurant.name} restaurant"
            )

    order_key = str(uuid.uuid4())
    cache = CacheService()

    cache.set(
        namespace="restaurants_order", key=order_key, instance=order_in_cache.orders
    )

    melange_order_processing.delay(order_in_cache)
    bueno_order_processing.delay(order_in_cache)


def schedule_order(order: Order):
    """Add the task to the queue for the future processing."""

    assert type(order.eta) is date

    # todo: remove
    # _schedule_order(order)
    # return None

    # 2025-03-06  -> 2025-03-06-00:00:00 UTC
    if order.eta == date.today():
        print(f"The order will be started processing now")
        return _schedule_order.apply_async(args=(order,))
    else:
        # ETA: 3:00AM will be sent to restaurant APIs
        eta = datetime.combine(order.eta, time(hour=3))
        print(f"The order will be started processing {eta}")
        return _schedule_order.apply_async(args=(order,), eta=eta)
        # return _schedule_order(order)
